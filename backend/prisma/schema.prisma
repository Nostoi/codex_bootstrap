generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String                 @id @default(cuid())
  email           String                 @unique
  name            String?
  avatar          String?
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  sessions        CollaborationSession[]
  documents       Document[]
  interactionLogs InteractionLog[]
  notifications   Notification[]
  projects        Project[]
  tasks           Task[]
  settings        UserSettings?
  calendarEvents  CalendarEvent[]
  calendarSyncStates CalendarSyncState[]

  @@map("users")
}

model Document {
  id        String                 @id @default(cuid())
  title     String
  content   String?
  yjsState  Bytes?
  createdAt DateTime               @default(now())
  updatedAt DateTime               @updatedAt
  ownerId   String
  sessions  CollaborationSession[]
  owner     User                   @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  @@map("documents")
}

model CollaborationSession {
  id         String    @id @default(cuid())
  userId     String
  documentId String
  joinedAt   DateTime  @default(now())
  leftAt     DateTime?
  isActive   Boolean   @default(true)
  document   Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, documentId])
  @@map("collaboration_sessions")
}

model IntegrationConfig {
  id           String    @id @default(cuid())
  provider     String
  userId       String
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  scopes       String[]
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([provider, userId])
  @@map("integration_configs")
}

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  owner       User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  tasks       Task[]

  @@map("projects")
}

model Task {
  id               String           @id @default(cuid())
  title            String
  description      String?
  completed        Boolean          @default(false)
  status           TaskStatus       @default(TODO)
  dueDate          DateTime?
  energyLevel      EnergyLevel?
  focusType        FocusType?
  estimatedMinutes Int?
  priority         Int              @default(3)
  softDeadline     DateTime?
  hardDeadline     DateTime?
  source           TaskSource       @default(MANUAL)
  aiSuggestion     String?
  projectId        String?
  ownerId          String
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  notifications    Notification[]
  dependents       TaskDependency[] @relation("TaskDependents")
  dependencies     TaskDependency[] @relation("TaskDependencies")
  owner            User             @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  project          Project?         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tags             Tag[]            @relation("TagToTask")

  @@map("tasks")
}

model TaskDependency {
  id        String @id @default(cuid())
  taskId    String
  dependsOn String
  depends   Task   @relation("TaskDependents", fields: [dependsOn], references: [id], onDelete: Cascade)
  task      Task   @relation("TaskDependencies", fields: [taskId], references: [id], onDelete: Cascade)

  @@unique([taskId, dependsOn])
  @@map("task_dependencies")
}

model Notification {
  id               String              @id @default(cuid())
  message          String
  read             Boolean             @default(false)
  readAt           DateTime?
  notificationType NotificationType?
  deliveryStatus   DeliveryStatus?
  userId           String
  taskId           String?
  createdAt        DateTime            @default(now())
  task             Task?               @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

model InteractionLog {
  id        String   @id @default(cuid())
  userId    String
  action    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("interaction_logs")
}

model UserSettings {
  id                        String        @id @default(cuid())
  userId                    String        @unique
  theme                     String?       @default("light")
  notificationPreferences   Json?
  morningEnergyLevel        EnergyLevel?
  afternoonEnergyLevel      EnergyLevel?
  workStartTime             String?
  workEndTime               String?
  preferredFocusTypes       FocusType[]
  createdAt                 DateTime      @default(now())
  updatedAt                 DateTime      @updatedAt
  user                      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_settings")
}

model Tag {
  id    String @id @default(cuid())
  name  String
  tasks Task[] @relation("TagToTask")

  @@map("tags")
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  BLOCKED
  DONE
}

enum EnergyLevel {
  LOW
  MEDIUM
  HIGH
}

enum FocusType {
  CREATIVE
  TECHNICAL
  ADMINISTRATIVE
  SOCIAL
}

enum TaskSource {
  MANUAL
  AI_EXTRACTED
  CALENDAR
  EMAIL
  PRD
}

enum NotificationType {
  TASK_REMINDER
  TASK_OVERDUE
  ENERGY_SUGGESTION
  FOCUS_BREAK
  DAILY_PLANNING
  SYSTEM_UPDATE
}

enum DeliveryStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  READ
}

// Calendar sync models and enums
model CalendarEvent {
  id                String                   @id @default(cuid())
  graphId           String                   @unique
  subject           String
  body              String?
  bodyPreview       String?
  start             DateTime
  end               DateTime
  location          String?
  isAllDay          Boolean                  @default(false)
  importance        String?
  sensitivity       String?
  showAs            String?
  attendees         Json[]
  categories        String[]
  organizer         Json?
  recurrence        Json?
  rawData           Json
  lastModified      DateTime
  syncedAt          DateTime                 @default(now())
  userId            String?
  user              User?                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  syncConflicts     CalendarSyncConflict[]
  
  // Additional fields needed by GraphModule
  locallyModified   Boolean                  @default(false)
  remotelyModified  Boolean                  @default(false)
  graphEtag         String?
  graphCalendarId   String?
  description       String?
  lastSyncedAt      DateTime?
  syncStatus        CalendarSyncStatus?
  startTime         DateTime?
  endTime           DateTime?
  timeZone          String?
  isRecurring       Boolean                  @default(false)
  recurrencePattern String?

  @@map("calendar_events")
  @@index([graphId])
  @@index([userId])
  @@index([start, end])
  @@unique([userId, graphId])
}

model CalendarSyncState {
  id                String              @id @default(cuid())
  userId            String
  calendarId        String
  lastSyncToken     String?
  lastSyncTime      DateTime?
  lastSyncStatus    CalendarSyncStatus  @default(PENDING)
  errorMessage      String?
  syncedCount       Int                 @default(0)
  conflictCount     Int                 @default(0)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Additional fields needed by GraphModule
  status            CalendarSyncStatus  @default(PENDING)
  direction         SyncDirection       @default(BIDIRECTIONAL)
  totalEvents       Int?
  processedEvents   Int?
  deltaToken        String?
  lastDeltaSync     DateTime?
  lastFullSync      DateTime?
  syncedEvents      Int                 @default(0)
  conflictedEvents  Int                 @default(0)
  failedEvents      Int                 @default(0)
  
  @@map("calendar_sync_states")
  @@unique([userId, calendarId])
  @@index([userId])
  @@index([lastSyncStatus])
}

model CalendarSyncConflict {
  id                String                     @id @default(cuid())
  eventId           String
  conflictType      CalendarConflictType
  description       String
  localData         Json
  remoteData        Json
  resolution        CalendarConflictResolution @default(PENDING)
  resolvedAt        DateTime?
  resolvedBy        String?
  autoResolved      Boolean                    @default(false)
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt
  event             CalendarEvent              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Additional fields needed by GraphModule
  calendarEventId   String?
  conflictData      Json?
  syncStateId       String?
  localVersion      String?
  remoteVersion     String?
  autoResolvable    Boolean                    @default(false)
  
  @@map("calendar_sync_conflicts")
  @@index([eventId])
  @@index([conflictType])
  @@index([resolution])
}

enum CalendarSyncStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum CalendarConflictType {
  TITLE
  DESCRIPTION_MISMATCH
  START_TIME
  TIME_MISMATCH
  LOCATION_MISMATCH
  BOTH_MODIFIED
}

enum CalendarConflictResolution {
  PENDING
  USE_LOCAL
  USE_REMOTE
  MERGE
  MANUAL
}

enum SyncDirection {
  UPLOAD
  DOWNLOAD
  BIDIRECTIONAL
}
